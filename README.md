# Hypott - a Hypothesis Testing Library for Kotlin (jvm)

Hypott は, 小さなソフトウェア試験ライブラリです. 

Hypott は, Kotlin で書かれ, Kotlin (jvm) プロジェクトでの利用を想定していますが, どんなテスティング・フレームワークとも一緒に使うことができます (何ならテスティング・フレームワークなしでも, テストとは関係なく使うこともできるでしょう).

Hypott ができることは, 次の二つだけです.

-   「仮説」と呼ばれる試験の前提条件を記述すること
-   「仮説」を計算機の上で実行すること

## 仮説とは

Hypott で用いる「仮説 (Hypothesis)」という用語は以下のようなことを意味しています.

数学の述語論理を思い出してみましょう. それらは一般的にだいたい次のような形をしています.

-   何らかの性質を満たす任意の x0, x1, ... に対して --- (1)
-   ある特定の y0, y1, ... が存在して --- ()
-   (それらを変数としてもつ) ある論理式が成り立つ --- ()

ソフトウェア試験の目的は, このような論理式 (仮説) が本当に成り立つ (あるいは成り立たない) ことを証明することです.

従って, 試験コードには必ず (1)-(3) が記述されているはずなのですが, 実際にはこの三つが渾然一体となって明確な区別なく記述されていることも多く, その場合にはその試験の仕様そのものが試験コードを読んでもよく分からない, ということになりがちです.

ソフトウェア・コードでこのような論理式を表す方法として, いわゆるフォーマル・メソッドをサポートしたり, 強力な型システムを持つプログラミング言語もあります (Lean, VDM, Coq, ...). 最近はそれらも広く使われるようになってきているので, それらを使うのも一つの方法です.

ここでは Kotlin のような古くからあるプログラミング言語でも,

-   できる限り仮説を明確に表現でき
-   できる限り証明っぽいことができる (実際には証明のための基盤が存在しないので, 証明自体は無理)

ことを目指すのが, Hypott の目的です.

### 「任意の ... に対して」

「仮説」を旧来のプログラミング言語で表現する場合に難しいことの一つは, 「任意の何々」(仮説の構成要素 (1)) と「存在する何々」(仮説の構成要素 (2)) を区別することです.

なぜならば, 普通のプログラミング言語では「任意の何々」をそのまま表現する手段がないために, プログラマは何らかの具体的な値を記述せざるを得ず, そうするとコード上からは実際に存在/指定された値と区別ができなくなってしまうのです.

Hypott では, そのような前提条件 (1) を `forAny()` という関数で記述します (`forAny` は「任意の  に対して」という意味です).

そして, `forAny()` で指定された任意の値をソフトウェア試験実行時にランダムな値に置き換えることによって「証明の真似事」をしています. 「任意の値」をプログラマがいちいち適当な値を考え出して置き換える必要はありません.

もし, 「任意の値」の選択肢が (比較的少数の) 有限個しかなく, すべての選択肢の組み合わせを実行できたとしたら, それはある意味で「列挙による証明」ができたことになります. もちろん現実的なソフトウェア・コードでは, それは実現不可能ですが.

## Hypott.forAny()

`forAny()` 関数 (任意の何々について) は, 以下の引数を取ります.

-   klass: KClass<T>
-   variant: Map<String, Map> = emptyMap()
-   where: Any? = null

必須なのは klass だけで, 普通はソフトウェア試験の対象となるクラスを渡します.

```kotlin
val foo = hypott.forAny(Foo::class)
```

得られたインスタンスの各プロパティには, その方に適合した適当な値が疑似乱数を元に割り当てられています.

あるプロパティの値に対して条件を付けることもできます (`variant`).

また, ランダムではない, 特定の値を割り当てることもできます(`where`).

## Hypott()

Hypott のインスタンスは次のようにして作成します.

```kotlin
val hypott = Hypott()
```

引数として, 疑似乱数の元となる `seed: Long` を渡すこともできます. `seed` が決まると一連の疑似乱数の値は決定的に決まるので, 同じ `seed` を使うことによって再現性があります. `seed` を渡さなければ, 適当な疑似乱数が用いられます.

また, 疑似乱数を発生させる `kotlin.random.Random` を直接渡すこともできます. 複数の hypott インスタンスを同じ擬似乱数系列の中に置きたい場合に用います.

## Hypott に似たツール

Hypott に似たツールとして, `faker` と呼ばれるようなソフトウェア・ツールがたくさん提供されています. 特に JavaScript 系では, 郵便番号, 氏名のような人間にわかりやすい値を生成してくれるものがたくさんあります. ほとんどの `faker` は, それらしい値を生成することがおもな目的で, Hypott のように「仮説検証」というような考え方が背景にあるわけではありません.

Property-based Testing は, `faker` などに較べて, よりテストを中心にした考え方です. 特に Kotlin については, [Kotest](https://kotest.io/) がProperty-basde Testing ツールを提供しており, 実績や完成度から言って利用を検討すべき対象の一つです. ただし, 例えばデフォルトではテスト時にテストごとに 1,000 回の試行を行います. これを良しとするかどうかは, 使う人の世界観に依るでしょう.

テスト・データを生成する手法は, ソフトウェア工学の歴史の中でも, 1970 年代の IBM を初めとして今までも行われてきた手法です. 

Hypott は, `faker` や Property-base Testing に較べると, 「(テスト) 仕様を記述できること」がもっとも大きな目的です. テスト・データが生成されるのは, その結果に過ぎません. とは言うものの, 

-   テストを簡潔に記述できること
-   テスト・データが容易に生成できること

は, Hypott の大きな特徴ではあります. テスト・コードと, テストの対象となるプロダクト・コードは互いをメタとする相補的な関係にあるのです.